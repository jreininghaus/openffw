\subsection{Refine}
%
Given a triangulation $\T_\ell$ on the level $\ell$, let $\E_\ell$ denote its set of interior edges and suppose that $E(T)$ ($E(T):T\in\T_\ell$) denotes the given reference edges. There is no need to label the reference edges $E(T)$ by some level $\ell$ because $E(T)$ will be the same edge of $T$ in all triangulations $\T_m$ which include $T$. However, once $T$ in $\T_\ell$ is refined, the reference edges will change too.
After the closure algorithm each element has either $k = 0,1,2$ or 3 of 
its edges marked for refinement and because of the closure 
algorithm the reference edge belongs to it if $k\geq 1$. 
Therefore, exactly one of the four refinement rules of Figure~\ref{f:3} is applied.
This specifies sub triangles and their reference edges in the new triangulation $\mathcal{T}_{\ell+1}$.
In general there are four different cases to refine an element. 
Elements with no marked edges are not refined, elements with one marked edge
are refined \emph{green}, elements with 
two marked edges are refined \emph{blue} and elements with tree 
marked edges are refined \emph{red}. Where \emph{blue} refinement
is divided into the two cases \emph{blueleft} and \emph{blueright}.\bigskip


\begin{figure}[!ht]
\begin{center}
\setlength{\unitlength}{2cm}
\begin{picture}(5,1.1)

%red
\put(0,0){\line(1,0){2}}
\put(0,0){\line(1,1){1}}
\put(2,0){\line(-1,1){1}}
\put(0.5,0.5){\line(1,0){1}}
\put(1,0){\line(-1,1){0.5}}
\put(1,0){\line(1,1){0.5}}
\put(0.5,0.5){\circle*{0.05}}
\put(1,0){\circle*{0.05}}
\put(1.5,0.5){\circle*{0.05}}
\put(0,0.75){\emph{red}}
\put(-0.1,-0.05){1}
\put(0.96,1.02){3}
\put(2.02,-0.05){2}
\put(0.8,-0.2){$new_1$}
\put(0,0.5){$new_3$}
\put(1.6,0.5){$new_2$}
\put(0.7,0.55){\line(1,0){0.6}}
\put(0.7,0.45){\line(1,0){0.6}}
\put(0.2,0.05){\line(1,0){0.6}}
\put(1.2,0.05){\line(1,0){0.6}}


%green
\put(3,0){\line(1,0){2}}
\put(3,0){\line(1,1){1}}
\put(5,0){\line(-1,1){1}}
\put(4,0){\line(0,1){1}}
\put(4,0){\circle*{0.05}}
\put(3,0.75){\emph{green}}
\put(2.9,-0.05){1}
\put(3.96,1.02){3}
\put(5.02,-0.05){2}
\put(3.8,-0.2){$new_1$}
\put(3.2,0.1){\line(1,1){0.6}}
\put(4.8,0.1){\line(-1,1){0.6}}
\end{picture}
\vspace{1cm}

\begin{picture}(5,1)

%blue left
\put(0,0){\line(1,0){2}}
\put(0,0){\line(1,1){1}}
\put(2,0){\line(-1,1){1}}
\put(1,0){\line(0,1){1}}
\put(1,0){\line(-1,1){0.5}}
\put(0.5,0.5){\circle*{0.05}}
\put(1,0){\circle*{0.05}}
\put(0,0.75){\emph{blue left}}
\put(-0.1,-0.05){1}
\put(0.96,1.02){3}
\put(2.02,-0.05){2}
\put(0.8,-0.2){$new_1$}
\put(0,0.5){$new_2$}
\put(1.8,0.1){\line(-1,1){0.6}}
\put(0.2,0.05){\line(1,0){0.6}}
\put(0.9,0.25){\line(0,1){0.5}}

%blue right
\put(3,0){\line(1,0){2}}
\put(3,0){\line(1,1){1}}
\put(5,0){\line(-1,1){1}}
\put(4,0){\line(0,1){1}}
\put(4,0){\line(1,1){0.5}}
\put(4.5,0.5){\circle*{0.05}}
\put(4,0){\circle*{0.05}}
\put(2.8,0.75){\emph{blue right}}
\put(2.90,-0.05){1}
\put(3.96,1.02){3}
\put(5.02,-0.05){2}
\put(3.8,-0.2){$new_1$}
\put(4.6,0.5){$new_2$}
\put(3.2,0.1){\line(1,1){0.6}}
\put(4.2,0.05){\line(1,0){0.6}}
\put(4.1,0.25){\line(0,1){0.5}}

\end{picture}
\end{center}

\caption{\label{f:3} \emph{Red}, \emph{green} and \emph{blue} refinement.
         The new reference edge is marked through a second line in parallel opposite the new vertices 
         $new_1$, $new_2$ or $new_3$.}
\end{figure}


\noindent
All elements that are marked in refineElemsBisec5 are refined \emph{bisec5} instead of
\emph{red}, see Figure~\ref{f:4}.\bigskip

\begin{figure}[!ht]
\setlength{\unitlength}{2cm}
\begin{center}
\begin{picture}(2,1.1)
%bisec5
\put(0,0){\line(1,0){2}}
\put(0,0){\line(1,1){1}}
\put(2,0){\line(-1,1){1}}
\put(0.5,0.5){\line(1,0){1}}
\put(1,0){\line(-1,1){0.5}}
\put(1,0){\line(1,1){0.5}}
\put(1,0){\line(0,1){1}}
\put(0.5,0.5){\circle*{0.05}}
\put(1,0){\circle*{0.05}}
\put(1.5,0.5){\circle*{0.05}}
\put(1,0.5){\circle*{0.05}}
\put(-1,0.75){\emph{bisec5}}
\put(-0.10,-0.05){1}
\put(0.96,1.02){3}
\put(2.02,-0.05){2}
\put(0.8,-0.2){$new_1$}
\put(0,0.5){$new_3$}
\put(1.6,0.5){$new_2$}
\put(1,0.55){$new_4$}
%\put(0.25,-0.1){\vector(0,1){0.1}}
%\put(0.75,-0.1){\vector(0,1){0.1}}
%\put(0.73,0.2){\vector(-2,1){0.1}}
%\put(0.27,0.2){\vector(2,1){0.1}}
%\put(0.74,0.8){\vector(-2,-1){0.1}}
%\put(0.26,0.8){\vector(2,-1){0.1}}
\put(0.65,0.55){\line(1,1){0.2}}
\put(1.35,0.55){\line(-1,1){0.2}}
\put(0.2,0.05){\line(1,0){0.6}}
\put(1.2,0.05){\line(1,0){0.6}}
\put(0.9,0.175){\line(-1,1){0.2}}
\put(1.1,0.175){\line(1,1){0.2}}
\end{picture}
\vspace{1ex}
\end{center}
\caption{\label{f:4} \emph{bisec5} refinement. The new reference edge is marked through a second line in parallel opposite the new vertices $new_1$, $new_2$, $new_3$ and $new_4$.}
\end{figure}

\noindent
The red-green-blue refinement is implemented in\\
File: \path{.\algorithms\refine\redGreenBlue.m}
\begin{pcode}
function p = redGreenBlue(p) 
% input:   p - FFW
% output:  p - FFW
\end{pcode}
%
At first we create the new c4n. Therefore we take the old c4n 
and add the new coordinates at the end of the list. The new 
coordinates are the midpoints of the marked edges.
%
\begin{pcode}
% Create new node numbers from refineEdges
newNode4ed = zeros(1,nrEdges);
newNode4ed( find(refineEdges) ) = ...
     (nrNodes+1):(nrNodes+nnz(refineEdges));
% Create coordinates of the new nodes
[dontUse,J,S] = find(newNode4ed);
c4n(S,:) = midPoint4ed(J,:);
\end{pcode}
%
In the next step the new n4e is build. At first we calculate the 
number of marked edges for each element. All the Elements that will 
not be refined, e.g. have no marked edge, are fist copied to the new n4e.
In the following new elements will be appended to the list.
%
\begin{pcode}
newNode4e = newNode4ed(ed4e);
unrefinedElems = find( all(newNode4e == 0 ,2) );
refineElems = find( any(newNode4e,2) );
nrMarkedEd4MarkedElems = sum(refineEdges( ed4e(refineElems,:) ),2);
newn4e = n4e(unrefinedElems,:);
\end{pcode}


\noindent
All elements that are to be \emph{red} or \emph{green} refined can be refined simultaneously.
In the case of \emph{green} refinement, it is important to know that the first edge of an element is 
always the reference edge, therefore the marked edge, and that all elements have math. positive 
orientation, i.e. counter clockwise. Therefore there is only one
way to refine an element \emph{green}. 
Instead we have two different cases with \emph{blue} refinement. 
Therefore we distinguish between \emph{blueleft} and \emph{blueright}
refinement. Again there is only one way to perform \emph{red} refinement.
For example the MATLAB code for \emph{green} refinement is
printed below. The new elements are 
$T_1=\conv(2,3,new_1)$ and $T_1=\conv(3,1,new_1)$.
The new reference edge are the edges between the nodes
$2,3$ and $3,1$.
\begin{pcode}
I = find(nrMarkedEd4MarkedElems == 1);
if ~isempty(I)
  gElems = refineElems(I);
  [dontUse,dontUse,newN] = find( newNode4e(gElems,:)' );
  newGreenElems = [n4e(gElems,[2 3]) newN;...
                   n4e(gElems,[3 1]) newN];
  newn4e = [newn4e;newGreenElems];
end
\end{pcode}
%
At the end the lists for the boundary, Db and Nb, are
updated.
\begin{pcode}
Db = updateBoundary(Db,DbEd,newNode4ed);
Nb = updateBoundary(Nb,NbEd,newNode4ed);
...
function newBoundary = updateBoundary(oldB,ed4b,newNode4ed)
if(isempty(oldB))
    newBoundary = [];
else
  unrefinedEd = find(~newNode4ed(ed4b));
  refineEd = find(newNode4ed(ed4b));
  newBoundary = [oldB(unrefinedEd,:);...
    oldB(refineEd,1) newNode4ed(ed4b(refineEd))' ;...
    newNode4ed(ed4b(refineEd))' oldB(refineEd,2)];
end
\end{pcode}
